//Лабораторная работа 5-8

//сортировка выбором
import java.util.Arrays;


public class SelectionSort {
    
	public static void selectionSort(int[] arr) {
        
        
	for (int i = 0; i < arr.length; i++) {
            // поиск индекса минимального элемента в неотсортированнной части
            
		int minIndex = i;
		for (int j = i + 1; j < arr.length; j++) {
                
		if (arr[j] < arr[minIndex]) {
                    
			minIndex = j;
               
		}
            
	}
            
		int temp = arr[i];       
		arr[i] = arr[minIndex];
		arr[minIndex] = temp;
        
	}
    
    }

    
public static void main(String[] args) {
       
	int[] testArray = {64, 25, 12, 22, 11};
        
	System.out.println("Исходный массив: " + Arrays.toString(testArray));
        	selectionSort(testArray);
        
	System.out.println("Отсортированный массив: " + Arrays.toString(testArray));
    
	}

}



//сортировка обменом(пузырьком)
public class BubbleSort {
    
    
    public static void bubbleSort(int arr[]) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            // сравнение соседних элементов 
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    //временная переменная для обмена
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }


    public static void printArray(int arr[]) {
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
    
    public static void main(String[] args) {
        int arr[] = {64, 34, 25, 12, 22, 11, 90};
        
        System.out.println("Исходный массив: ");
        printArray(arr);
        
        bubbleSort(arr);
        
        System.out.println("Отсортированный массив: ");
        printArray(arr);
    }
}


//сортировка вставками 
public class InsertionSort {
    public static void insertionSort(int[] array) {
        for (int i = 1; i < array.length; i++) {
            int key = array[i]; //элемент который нужно  вставить в отсортирорванную часть
            int j = i - 1; 
            while (j >= 0 && array[j] > key) {
                array[j + 1] = array[j];
                j = j - 1;
            }
            array[j + 1] = key; 
        }
    }
    
    public static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
        System.out.println();
    }
    public static void main(String[] args) {
        int[] array = {12, 11, 13, 5, 6};
        System.out.println("Исходный массив:");
        printArray(array);
        insertionSort(array);
        System.out.println("Отсортированный массив:");
        printArray(array);
    }
}


//сортировка слиянием
import java.util.*;

public class MergeSort {
    
    public static List<Integer> mergeSort(List<Integer> arr) {
        if (arr.size() <= 1) {
            return new ArrayList<>(arr);
        }
        
        //делим массив на две половины
        int mid = arr.size() / 2;
    
        List<Integer> left = new ArrayList<>(arr.subList(0, mid));
        List<Integer> right = new ArrayList<>(arr.subList(mid, arr.size()));
        
        //рекрсивно сортируем обе части
        left = mergeSort(left);
        right = mergeSort(right);
        
        // объединяем отсортированные половины
        return merge(left, right);
    }
    
    public static List<Integer> merge(List<Integer> left, List<Integer> right) {
        List<Integer> result = new ArrayList<>();
        int i = 0, j = 0;
        
        while (i < left.size() && j < right.size()) {
            if (left.get(i) < right.get(j)) {
                result.add(left.get(i));
                i++;
            } else {
                result.add(right.get(j));
                j++;
            }
        }
        
        while (i < left.size()) {
            result.add(left.get(i));
            i++;
        }
        
        while (j < right.size()) {
            result.add(right.get(j));
            j++;
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        List<Integer> array = Arrays.asList(38, 27, 43, 3, 9, 82, 10);
        System.out.println("Исходный массив: " + array);
        List<Integer> sortedArray = mergeSort(array);
        System.out.println("Отсортированный массив: " + sortedArray);
    }
}


//сортировка Шелла
import java.util.ArrayList;

public class ShellSort {
    public static void shellSort(ArrayList<Integer> arr) {
        int n = arr.size();
        // начинаем с большей части и сокращаем ее
        for (int gap = n / 2; gap > 0; gap /= 2) {
            for (int i = gap; i < n; i++) {
                // Добавляем a[i] к элементам отсортировнаного массива
                int temp = arr.get(i);
                int j;
                for (j = i; j >= gap && arr.get(j - gap) > temp; j -= gap) {
                    arr.set(j, arr.get(j - gap));
                }
                arr.set(j, temp);
            }
        }
    }

    public static void printArray(ArrayList<Integer> arr) {
        for (int num : arr) {
            System.out.print(num + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        //пример
        ArrayList<Integer> arr = new ArrayList<>();
        arr.add(12);
        arr.add(34);
        arr.add(54);
        arr.add(2);
        arr.add(3);
        System.out.print("Original array: ");
        printArray(arr);
        shellSort(arr);
        System.out.print("Sorted array: ");
        printArray(arr);
    }
}


//быстрая сортировка
import java.util.Arrays;

public class QuickSort {
    public static void main(String[] args) {
        int[] array = {10, 7, 8, 9, 1, 5};
        System.out.println("Исходный массив:");
        printArray(array);
        quickSort(array, 0, array.length - 1);
        System.out.println("\nОтсортированный массив:");
        printArray(array);
    }

    // метод сортировки
    public static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            int pi = partition(array, low, high);

            //рекурсивная сортировка
            quickSort(array, low, pi - 1);
            quickSort(array, pi + 1, high);
        }
    }

    private static int partition(int[] array, int low, int high) {
        // Choose the rightmost element as the pivot
        int pivot = array[high];
        int i = (low - 1); //индекс наименьшего элемента

        for (int j = low; j < high; j++) {
            if (array[j] <= pivot) {
                i++;

                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }
        int temp = array[i + 1];
        array[i + 1] = array[high];
        array[high] = temp;

        return i + 1;
    }

        private static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
        System.out.println();
    }
}


//пирамидальная сортировка
public static void heapify(int[] arr, int n, int i) {
    int largest = i; // Initialize largest as root
    int left = 2 * i + 1; // left = 2*i + 1
    int right = 2 * i + 2; // right = 2*i + 2

    // Проверьте, не превышает ли левый дочерний элемент размер корня
    if (left < n && arr[i] < arr[left])
        largest = left;

    // Проверьте, не больше ли размер правого дочернего элемента, чем самый большой на данный момент
    if (right < n && arr[largest] < arr[right])
        largest = right;

    // При необходимости поменяйте местами
    if (largest != i) {
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;

        // Рекурсивно сугрппировать поддерево в кучу
        heapify(arr, n, largest);
    }
}

public static void heapSort(int[] arr) {
    int n = arr.length;

    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    for (int i = n - 1; i > 0; i--) {
        // Переместить текущий в конец
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        heapify(arr, i, 0);
    }
}

public static void main(String[] args) {
    int[] arr = {12, 11, 13, 5, 6, 7};
    System.out.println("Исходный массив: " + Arrays.toString(arr));

    heapSort(arr);

    System.out.println("Отсортированный массив: " + Arrays.toString(arr));
}



//последовательный поиск
public class Main {
    // Функция линейного поиска
    public static int linearSearch(int[] arr, int size, int target) {
        for (int i = 0; i < size; i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        // Создание массива
        int[] array = {3, 5, 2, 7, 9, 1, 4};
        int size = array.length; // Вычисление размера массива
        int target = 7; // Target value

        // Вызов функции поиска
        int result = linearSearch(array, size, target);

        // результат
        if (result != -1) {
            System.out.println("Element found at position: " + result);
        } else {
            System.out.println("Element not found");
        }
    }
}


//бинарный поиск
public class BinarySearch {
    public static int binarySearch(int[] array, int target) {
        int left = 0; // Ëåâàÿ ãðàíèöà ïîèñêà
        int right = array.length - 1; 
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (array[mid] == target) {
                return mid;
            }
            if (array[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return -1; 
    }

    public static void main(String[] args) {
        int[] sortedArray = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
        int target = 7;
        int result = binarySearch(sortedArray, target);
        if (result != -1) {
            System.out.println("Элемент найден: " + result);
        } else {
            System.out.println("Элемент не найден");
        }
    }
}
  


//интерполлирующий поиск
public class InterpolationSearch {
    public static int interpolationSearch(int[] arr, int lo, int hi, int x) {
        if (lo <= hi && x >= arr[lo] && x <= arr[hi]) {
            int pos = lo + ((hi - lo) * (x - arr[lo])) / (arr[hi] - arr[lo]);

            // Состояние, при котором эл-нт найден
            if (arr[pos] == x) {
                return pos;
            }
            // Если x больше, то x находится в правом подмассиве
            if (arr[pos] < x) {
                return interpolationSearch(arr, pos + 1, hi, x);
            }
            // Если x меньше, то x находится в левом подмассиве
            if (arr[pos] > x) {
                return interpolationSearch(arr, lo, pos - 1, x);
            }
        }
        return -1;
    }
}

//поиск фибоначчи
import java.util.*;

public class FibonacciSearch {

    public static int fibonacci(int n) {
        if (n <= 1)
            return n;
        int[] fib = new int[n + 2];
        fib[0] = 0;
        fib[1] = 1;
        for (int i = 2; i <= n; i++)
            fib[i] = fib[i - 1] + fib[i - 2];
        return fib[n];
    }

   
    public static int fibonacciSearch(List<Integer> arr, int x) {
        int n = arr.size()
        int fib_m2 = 0; 
        int fib_m1 = 1; 
        int fib_m = fib_m2 + fib_m1;

        while (fib_m < n) {
            fib_m2 = fib_m1;
            fib_m1 = fib_m;
            fib_m = fib_m2 + fib_m1;
        }
        int offset = -1;

        while (fib_m > 1) {
            int i = Math.min(offset + fib_m2, n - 1);

            // если x больше подмассива
            if (arr.get(i) < x) {
                fib_m = fib_m1;
                fib_m1 = fib_m2;
                fib_m2 = fib_m - fib_m1;
                offset = i;
            }
            
            else if (arr.get(i) > x) {
                fib_m = fib_m2;
                fib_m1 = fib_m1 - fib_m2;
                fib_m2 = fib_m - fib_m1;
            }
            else
                return i;
        }

        if (fib_m1 == 1 && offset + 1 < n && arr.get(offset + 1) == x)
            return offset + 1;

        return -1; 
    }

    public static void main(String[] args) {
        List<Integer> arr = Arrays.asList(10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100);
        int x = 85;
        int result = fibonacciSearch(arr, x);
        if (result != -1)
            System.out.println("Элемент найден: " + result);
        else
            System.out.println("Элемент не найден");
    }
}

