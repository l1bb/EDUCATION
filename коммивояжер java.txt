import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class TravelingSalesman {

    private int numCities;
    private int[][] distanceMatrix;
    private int minDistance = Integer.MAX_VALUE;
    private List<Integer> shortestPath = new ArrayList<>();

    public TravelingSalesman(int[][] matrix) {
        this.distanceMatrix = matrix;
        this.numCities = matrix.length;
    }

    public void solve() {
        List<Integer> currentPath = new ArrayList<>();
        boolean[] visited = new boolean[numCities];

        // Начинаем с первого города (индекс 0)
        currentPath.add(0);
        visited[0] = true;

        findShortestPath(currentPath, visited, 0);
    }

    private void findShortestPath(List<Integer> currentPath, boolean[] visited, int currentDistance) {
        // Если все города посещены
        if (currentPath.size() == numCities) {
            // Возвращаемся в начальный город
            int lastCity = currentPath.get(currentPath.size() - 1);
            int distanceToStart = distanceMatrix[lastCity][0];

            // Если есть путь в начальный город
            if (distanceToStart != 0) {
                int totalDistance = currentDistance + distanceToStart;

                if (totalDistance < minDistance) {
                    minDistance = totalDistance;
                    shortestPath = new ArrayList<>(currentPath);
                    shortestPath.add(0); // Добавляем возвращение в начальный город
                }
            }
            return;
        }

        // Перебираем все города, кроме текущего
        for (int nextCity = 0; nextCity < numCities; nextCity++) {
            if (!visited[nextCity]) {
                int lastCity = currentPath.get(currentPath.size() - 1);
                int distToNext = distanceMatrix[lastCity][nextCity];

                // Если есть путь из последнего города в следующий
                if (distToNext != 0) {
                    visited[nextCity] = true;
                    currentPath.add(nextCity);

                    findShortestPath(currentPath, visited, currentDistance + distToNext);

                    
                    currentPath.remove(currentPath.size() - 1);
                    visited[nextCity] = false;
                }
            }
        }
    }

    public int getMinDistance() {
        return minDistance;
    }

    public List<Integer> getShortestPath() {
        return shortestPath;
    }
