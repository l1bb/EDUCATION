#ЛАБОРАТОРНАЯ РАБОТА 11-12
#Варианты 3,6,9,10,13,16

#вариант3(Напишите рекурсивную функцию для нахождения наибольшего общего делителя (НОД) двух чисел, используя алгоритм Евклида.)

def gcd_recursive(a, b):
  """
  с помощью алгоритма Евклида находит НОД а и b
  """
  if b == 0:
    return a
  else:
    return gcd_recursive(b, a % b)

#Пример
num1 = 30
num2 = 24
result = gcd_recursive(num1, num2)
print(f"НОД чисел {num1} и {num2} равен {result}")

#6вариант(Создайте рекурсивную функцию для подсчета количества гласных букв в строке.)
def count_vowels_recursive(input_string):
    vowels = "aeiouаеёиоуыэюя"  #включаем и русские и английские гласные буквы
    input_string = input_string.lower()  #Приведение строки к нижнему регистру

    if not input_string:  #возврат 0, если строка пустая 
        return 0
    
    first_char = input_string[0]
    
    # Рекурсия 
    if first_char in vowels:
        return 1 + count_vowels_recursive(input_string[1:])
    else:
        return 0 + count_vowels_recursive(input_string[1:])

#Пример
string_to_check = "Шла Саша по шоссе"
result = count_vowels_recursive(string_to_check)
print(f"количество гласных: {result}") 

#9вариант(Создайте рекурсивную функцию для проверки, отсортирован ли массив)
def is_sorted_recursive(arr):
    #пустой массив или состоящий из одного элемента считается отсортированным
    if len(arr) < 2:
        return True
    #рекурсия
    if arr[0] > arr[1]:
        return False
    return is_sorted_recursive(arr[1:])

#примеры
my_list1 = [1, 2, 3, 4, 5]
my_list2 = [1, 3, 2, 4, 5]
my_list3 = [5]
my_list4 = []

print(f"Массив {my_list1} отсортирован? {is_sorted_recursive(my_list1)}")
print(f"Массив {my_list2} отсортирован? {is_sorted_recursive(my_list2)}")
print(f"Массив {my_list3} отсортирован? {is_sorted_recursive(my_list3)}")
print(f"Массив {my_list4} отсортирован? {is_sorted_recursive(my_list4)}")

#вариант10(Реализуйте генерацию всех бинарных строк длины n.)
import itertools

def generate_binary_strings_itertools(n):
    """
    С помощью itertools генерирует все бинарные строки длины n
    """
    # 0 и 1 - элементы для повторения
    for bits in itertools.product('01', repeat=n):
        #Объединение в одну строку
        yield "".join(bits)

#пример
n = 3
print(f"все бинарные строки длины {n}:")
for s in generate_binary_strings_itertools(n):
    print(s)

#вариант13(Решите задачу о расстановке N ферзей для N = 8)

def solve_nqueens(n):
    """
    Основная функция
    """
    #список для хранения найденных решений
    solutions = []
    
    def is_safe(row, col, current_queens):
        """
        проверка возможности разместить ферзя
        """
        for queen_row, queen_col in enumerate(current_queens):
            #проверка на ту же вертикаль:
            if queen_col == col:
                return False
            #проверка на диагонали
            if abs(queen_row - row) == abs(queen_col - col):
                return False
        return True

    def backtrack(row, current_queens_cols):
        """
        рекурсивная функция
        """
        if row == n:
            solutions.append(current_queens_cols[:]) #добавление копии решения
            return

        #перебор всевозможных столбцов для этой строки
        for col in range(n):
            if is_safe(row, col, current_queens_cols):
                #если возможно поставить ферзя и переходим дальше
                current_queens_cols.append(col)
                backtrack(row + 1, current_queens_cols)
                #возврат: убираем ферзя чтобы попробовать другие столбцы
                current_queens_cols.pop()

    #начинаем с пустой доски с превой строки	
    backtrack(0, [])
    return solutions

def print_solution(solution):
    """
    функция для вывода одного решения
    Q ферзь, - пустая клетка
    """
    n = len(solution)
    for row in range(n):
        line = ""
        for col in range(n):
            if solution[row] == col:
                line += "Q "
            else:
                line += ". "
        print(line)
    print("\n")

# запуск при N=8 
N = 8
all_solutions = solve_nqueens(N)

print(f"всего найдено решений для N={N}: {len(all_solutions)}\n")
print_solution(all_solutions[0])

#вариант16(Реализуйте три вида обхода бинарного дерева (preorder, inorder, postorder))
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
class BinaryTreeTraversal:
    def __init__(self, root: TreeNode):
        self.root = root
    
    def preorder_traversal(self, node):
        """Preorder: корень -> левое поддерево -> правое поддерево"""
        if node is None:
            return []
        
        result = []
        result.append(node.val)
        result.extend(self.preorder_traversal(node.left))
        result.extend(self.preorder_traversal(node.right))
        
        return result

    def inorder_traversal(self, node):
        """Inorder: левое поддерево -> корень -> правое поддерево"""
        if node is None:
            return []

        result = []
        result.extend(self.inorder_traversal(node.left))
        result.append(node.val)
        result.extend(self.inorder_traversal(node.right))
        
        return result

    def postorder_traversal(self, node):
        """Postorder: левое поддерево -> правое поддерево -> корень"""
        if node is None:
            return []

        result = []
	result.extend(self.postorder_traversal(node.left))
        result.extend(self.postorder_traversal(node.right))
        result.append(node.val)
        
        return result
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
root.right.right = TreeNode(6)

# пример
tree_traverser = BinaryTreeTraversal(root)

print("Пример обхода бинарного дерева:")

# preorder: 1 -> 2 -> 4 -> 5 -> 3 -> 6
print(f"прямой обход (Preorder):   {tree_traverser.preorder_traversal(root)}")

# inorder: 4 -> 2 -> 5 -> 1 -> 3 -> 6
print(f"центрированный обход (Inorder): {tree_traverser.inorder_traversal(root)}")

# postorder: 4 -> 5 -> 2 -> 6 -> 3 -> 1
print(f"обратный обход (Postorder):  {tree_traverser.postorder_traversal(root)}")


КОНТРОЛЬНЫЕ ВОПРОСЫ:
1.Рекурсия - когда функция вызывает сама себя. Обязательные компоненты:
Базовый случай (условие выхода)
Рекурсивный шаг (вызов себя с упрощённой задачей)

2.Прямая рекурсия - функция вызывает себя напрямую. Косвенная рекурсия - функция A вызывает B а B вызывает A.

3.Неэффективность Фибоначчи возникает из-за повторных вычислений одних и тех же значений. Время выполнения растет экспоненциально O(2ⁿ).

4.Мемоизация - кэширование результатов вызовов функции. При повторных вызовах с теми же аргументами возвращает сохранённый результат избегая пересчёта.

5."Разделяй и властвуй" в сортировке слиянием:
Разделяй: разбиваем массив пополам
Властвуй: рекурсивно сортируем половины
Объединяй: сливаем отсортированные половины

6.Backtracking - метод поиска с возвратом: пробуем варианты если путь не ведёт к решению - откатываемся и пробуем другой вариант.

7.Сложность N ферзей - O(n!) поскольку перебираются все возможные расстановки ферзей.

8.Перестановок - n! (n-факториал) для множества из n элементов.

9.Перестановки - упорядоченные наборы (порядок важен). Сочетания - неупорядоченные наборы (порядок не важен).

10.DFS - идём вглубь до конца затем возвращаемся. BFS - обходим уровень за уровнем всех соседей перед переходом на следующий уровень.